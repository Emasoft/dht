#!/usr/bin/env python3\n"""\nAct Integration module.\n\nCopyright (c) 2024 Emasoft (Emanuele Sabetta)\nLicensed under the MIT License. See LICENSE file for details.\n"""\n\n# HERE IS THE CHANGELOG FOR THIS VERSION OF THE CODE:\n# - Created act integration module for local GitHub Actions testing\n# - Integrates with container build system for isolation\n# - Supports both standalone act and gh extension\n# - Provides deterministic CI/CD testing environment\n# - Refactored into smaller modules to reduce file size\n#\n\n"""\nAct integration for DHT - Run GitHub Actions locally.\nProvides isolated, deterministic CI/CD testing environment.\n"""\n\nimport subprocess\nfrom pathlib import Path\n\nfrom prefect import flow, get_run_logger, task\nfrom rich.console import Console\nfrom rich.panel import Panel\nfrom rich.table import Table\n\nfrom DHT.modules.act_command_builder import ActCommandBuilder\nfrom DHT.modules.act_container_manager import ActContainerManager\n\n# Import extracted modules\nfrom DHT.modules.act_integration_models import ActCheckResult, ActConfig, WorkflowInfo\nfrom DHT.modules.act_linter import ActLinter\nfrom DHT.modules.act_setup_manager import ActSetupManager\nfrom DHT.modules.act_workflow_manager import ActWorkflowManager\nfrom typing import Any\n\nconsole = Console()\n\n# Check if container runner is available\ntry:\n    import importlib.util\n\n    HAS_CONTAINER_RUNNER = importlib.util.find_spec("act_container_setup") is not None\nexcept ImportError:\n    HAS_CONTAINER_RUNNER = False\n\n\nclass ActIntegration:\n    """Integrates act with DHT for local GitHub Actions testing."""\n\n    def __init__(self, project_path: Path) -> None:\n        self.project_path = Path(project_path).resolve()\n        self.workflows_path = self.project_path / ".github" / "workflows"\n        self.venv_path = self.project_path / ".venv"\n        self.act_config_path = self.venv_path / "dht-act"\n        self.container_config = None\n\n        # Initialize helper classes\n        self.workflow_manager = ActWorkflowManager(project_path)\n        self.linter = ActLinter(project_path)\n        self.setup_manager = ActSetupManager(project_path)\n        self.container_manager = ActContainerManager(project_path)\n\n    def has_workflows(self) -> bool:\n        """Check if project has GitHub workflows."""\n        return self.workflow_manager.has_workflows()\n\n    def get_workflows(self) -> list[WorkflowInfo]:\n        """Get list of workflows with their metadata."""\n        return self.workflow_manager.get_workflows()\n\n    def lint_workflows(self, use_docker: bool = False) -> dict[str, Any]:\n        """Lint GitHub Actions workflows using actionlint.\n\n        Actionlint performs static analysis of workflow files to catch:\n        - Syntax errors\n        - Invalid action references\n        - Type mismatches\n        - Shell script issues (via shellcheck)\n\n        This is different from 'act' which actually executes workflows.\n        """\n        return self.linter.lint_workflows(use_docker=use_docker)\n\n    def _check_docker_available(self) -> bool:\n        """Check if Docker is available."""\n        return self.linter._check_docker_available()\n\n    def lint_with_docker(self, tag: str = "latest", color: bool = True) -> dict[str, Any]:\n        """Run actionlint using official Docker image.\n\n        This is the recommended way to run actionlint as it includes\n        all dependencies (shellcheck, pyflakes) in the container.\n        """\n        return self.linter.lint_with_docker(tag=tag, color=color)\n\n    def _parse_actionlint_output(self, output: str, results: dict[str, Any]) -> None:\n        """Parse actionlint JSON output and update results."""\n        return self.linter._parse_actionlint_output(output, results)\n\n    def check_act_available(self) -> ActCheckResult:\n        """Check if act is available via various methods."""\n        result = self.setup_manager.check_act_available()\n        # Convert to legacy format for compatibility\n        return {\n            "gh_extension": result.act_extension_installed,\n            "standalone_act": result.standalone_act_available,\n            "container_act": self.container_manager.setup_container_environment().runtime_available,\n            "preferred_method": result.preferred_method,\n        }\n\n    def install_gh_act_extension(self) -> bool:\n        """Install the gh act extension."""\n        return self.setup_manager.install_gh_act_extension()\n\n    def setup_act_config(self, config: ActConfig | None = None) -> Path:\n        """Set up act configuration in project."""\n        return self.setup_manager.setup_act_config(config)\n\n    def _get_container_socket(self, runtime: str) -> str:\n        """Get container runtime socket path."""\n        return self.container_manager._get_container_socket(runtime)\n\n    def _get_container_act_command(self) -> list[str]:\n        """Get command to run act inside a container."""\n        return self.container_manager._get_container_act_command(ActConfig())\n\n    def setup_container_environment(self) -> dict[str, Any]:\n        """Set up container environment for act."""\n        container_result = self.container_manager.setup_container_environment()\n        # Convert to legacy format for compatibility\n        return {\n            "container_config_created": container_result.success,\n            "act_image_available": container_result.success,\n            "runtime_available": container_result.runtime_available,\n            "runtime": container_result.runtime,\n            "error": container_result.error,\n        }\n\n    def get_act_command(self, event: str = "push", job: str | None = None, use_container: bool = False) -> list[str]:\n        """Get the act command to run."""\n        availability = self.check_act_available()\n        config = ActConfig()\n        builder = ActCommandBuilder(self.project_path, config)\n\n        # Build command using command builder\n        return builder.get_act_command(\n            event=event, job=job, use_container=use_container, preferred_method=availability["preferred_method"]\n        )\n\n    def list_workflows_and_jobs(self) -> dict[str, Any]:\n        """List all workflows and their jobs."""\n        result = self.workflow_manager.list_workflows_and_jobs()\n        result["act_available"] = self.check_act_available()\n        return result\n\n\n@task(name="lint_workflows", description="lint_workflows")  # type: ignore[misc]  # type: ignore[misc]\ndef lint_workflows_task(project_path: Path, use_docker: bool = False) -> dict[str, Any]:\n    """Lint GitHub Actions workflows.\n\n    This performs static analysis to catch errors before execution.\n    Use 'act' to actually run the workflows.\n    """\n    logger = get_run_logger()\n    integration = ActIntegration(project_path)\n\n    logger.info("Linting GitHub Actions workflows (static analysis)...")\n    lint_results = integration.lint_workflows(use_docker=use_docker)\n\n    return lint_results\n\n\n@task(name="check_act_setup", description="check_act_setup")  # type: ignore[misc]  # type: ignore[misc]\ndef check_act_setup(project_path: Path) -> dict[str, Any]:\n    """Check if act is set up for the project."""\n    logger = get_run_logger()\n    integration = ActIntegration(project_path)\n\n    if not integration.has_workflows():\n        logger.info("No GitHub workflows found")\n        return {"has_workflows": False}\n\n    logger.info(f"Found workflows in {integration.workflows_path}")\n\n    availability = integration.check_act_available()\n    workflows = integration.get_workflows()\n\n    return {"has_workflows": True, "workflows": workflows, "act_availability": availability}\n\n\n@task(name="setup_act_environment", description="setup_act_environment")  # type: ignore[misc]  # type: ignore[misc]\ndef setup_act_environment(project_path: Path, config: ActConfig | None = None) -> str:\n    """Set up act environment for the project."""\n    logger = get_run_logger()\n    integration = ActIntegration(project_path)\n\n    # Install gh extension if available and not installed\n    availability = integration.check_act_available()\n    if not availability["gh_extension"] and availability.get("gh_available"):  # type: ignore[attr-defined]\n        logger.info("Installing gh act extension...")\n        if integration.install_gh_act_extension():\n            logger.info("✅ gh act extension installed")\n        else:\n            logger.warning("Failed to install gh act extension")\n\n    # Setup configuration\n    config_path = integration.setup_act_config(config)\n    logger.info(f"Act configuration created at: {config_path}")\n\n    return str(config_path)\n\n\n@task(name="run_workflow", description="run_workflow")  # type: ignore[misc]  # type: ignore[misc]\ndef run_workflow(\n    project_path: Path,\n    event: str = "push",\n    job: str | None = None,\n    timeout: int = 1800,  # 30 minutes\n    use_container: bool = False,\n) -> dict[str, Any]:\n    """Run a GitHub workflow locally with act."""\n    logger = get_run_logger()\n    integration = ActIntegration(project_path)\n\n    # Setup container environment if requested\n    if use_container:\n        logger.info("Setting up container environment for act...")\n\n        # Use enhanced container runner if available\n        if HAS_CONTAINER_RUNNER:\n            from act_container_setup import ActContainerRunner\n\n            runner = ActContainerRunner(project_path)\n\n            # Check for config files\n            secrets_file = integration.act_config_path / ".secrets"\n            env_file = integration.act_config_path / ".env"\n\n            logger.info("Using enhanced container runner for isolated execution")\n            result = runner.run_act(\n                event=event,\n                job=job,\n                secrets_file=secrets_file if secrets_file.exists() else None,\n                env_file=env_file if env_file.exists() else None,\n                verbose=False,\n            )\n            return result\n        else:\n            # Fallback to basic container setup\n            container_setup = integration.setup_container_environment()\n            if not container_setup.get("act_image_available"):\n                return {"success": False, "error": "Failed to setup container environment", "details": container_setup}\n\n    # Get command\n    try:\n        cmd = integration.get_act_command(event, job, use_container)\n    except RuntimeError as e:\n        logger.error(str(e))\n        return {"success": False, "error": str(e)}\n\n    logger.info(f"Running: {' '.join(cmd)}")\n\n    # Run the workflow\n    try:\n        result = subprocess.run(cmd, cwd=str(project_path), capture_output=True, text=True, timeout=timeout)\n\n        return {\n            "success": result.returncode == 0,\n            "stdout": result.stdout,\n            "stderr": result.stderr,\n            "command": " ".join(cmd),\n        }\n\n    except subprocess.TimeoutExpired:\n        logger.error(f"Workflow timed out after {timeout} seconds")\n        return {"success": False, "error": f"Timeout after {timeout} seconds"}\n\n\n@flow(name="act_workflow")\ndef act_workflow_flow(\n    project_path: str,\n    event: str = "push",\n    job: str | None = None,\n    setup_only: bool = False,\n    lint_only: bool = False,\n    use_container: bool = False,\n) -> dict[str, Any]:\n    """\n    Run GitHub Actions locally using act.\n\n    Args:\n        project_path: Path to the project\n        event: GitHub event to simulate (push, pull_request, etc.)\n        job: Specific job to run (optional)\n        setup_only: Only setup, don't run workflows\n        lint_only: Only lint workflows, don't run them\n        use_container: Run act inside a container for isolation\n\n    Returns:\n        Dictionary with results\n    """\n    logger = get_run_logger()\n    project_path = Path(project_path).resolve()\n\n    console.print(\n        Panel.fit(\n            f"🎬 DHT Act Integration\n"\n            f"📁 Project: {project_path.name}\n"  # type: ignore[attr-defined]\n            f"🎯 Event: {event}\n\n"\n            f"[dim]Act runs workflows locally, simulating GitHub Actions.\n"\n            f"For syntax validation only, use --lint with actionlint.[/dim]",\n            style="bold blue",\n        )\n    )\n\n    # Check setup\n    console.print("\n[yellow]🔍 Checking GitHub Actions setup...[/yellow]")\n    setup_info = check_act_setup(project_path)\n\n    if not setup_info["has_workflows"]:\n        console.print("[yellow]ℹ️  No GitHub workflows found in .github/workflows/[/yellow]")\n        return {"success": True, "message": "No workflows to run"}\n\n    # Display workflows\n    table = Table(title="GitHub Workflows", show_header=True)\n    table.add_column("File", style="cyan")\n    table.add_column("Name", style="white")\n    table.add_column("Triggers", style="green")\n    table.add_column("Jobs", style="yellow")\n\n    for workflow in setup_info["workflows"]:\n        triggers = []\n        if isinstance(workflow.get("on"), dict):\n            triggers = list(workflow["on"].keys())\n        elif isinstance(workflow.get("on"), list):\n            triggers = workflow["on"]\n        elif isinstance(workflow.get("on"), str):\n            triggers = [workflow["on"]]\n\n        table.add_row(\n            workflow["file"], workflow.get("name", ""), ", ".join(triggers), ", ".join(workflow.get("jobs", []))\n        )\n\n    console.print(table)\n\n    # Check act availability\n    availability = setup_info["act_availability"]\n    console.print("\n[yellow]🔧 Act availability:[/yellow]")\n    console.print(f"  gh extension: {'✅' if availability['gh_extension'] else '❌'}")\n    console.print(f"  standalone act: {'✅' if availability['standalone_act'] else '❌'}")\n    console.print(f"  container act: {'✅' if availability['container_act'] else '❌'}")\n\n    if use_container:\n        console.print("\n[cyan]🐳 Container mode requested[/cyan]")\n        if not availability["container_act"]:\n            console.print("[red]❌ No container runtime available![/red]")\n            console.print("   Install Podman or Docker to use container mode")\n            return {"success": False, "error": "Container runtime not available"}\n\n    # Lint workflows with actionlint (static analysis - doesn't execute workflows)\n    console.print("\n[yellow]🔍 Linting workflows with actionlint (static analysis)...[/yellow]")\n    console.print("[dim]Note: This validates syntax but doesn't run workflows. Use 'dhtl act' to execute them.[/dim]")\n    lint_results = lint_workflows_task(project_path)\n\n    if lint_results["has_actionlint"]:\n        if lint_results["total_issues"] > 0:\n            console.print("\n[red]❌ Workflow validation failed![/red]")\n            console.print(f"Found {lint_results['total_issues']} issue(s):\n")\n\n            for workflow, issues in lint_results["workflows"].items():\n                console.print(f"[yellow]{workflow}:[/yellow]")\n                for issue in issues:\n                    console.print(f"  Line {issue['line']}, Col {issue['column']}: {issue['message']}")\n                console.print()\n        else:\n            console.print("[green]✅ All workflows passed validation![/green]")\n    else:\n        console.print("[yellow]⚠️  actionlint not available[/yellow]")\n        console.print("   Install with: brew install actionlint")\n\n    if lint_only:\n        return {\n            "success": lint_results["total_issues"] == 0 if lint_results["has_actionlint"] else True,\n            "lint_results": lint_results,\n        }\n\n    # Check act availability for running workflows\n    if not availability["preferred_method"]:\n        console.print("\n[red]❌ No act runner available![/red]")\n        console.print("\nInstall act using one of these methods:")\n        console.print("  1. gh extension install https://github.com/nektos/gh-act")\n        console.print("  2. brew install act")\n        console.print("  3. Install Podman/Docker for container-based act")\n        return {"success": False, "error": "No act runner available"}\n\n    # Setup environment\n    console.print("\n[yellow]📋 Setting up act environment...[/yellow]")\n    config_path = setup_act_environment(project_path)\n    console.print(f"✅ Configuration created at: {config_path}")\n\n    if setup_only:\n        console.print("\n[green]✅ Act setup complete![/green]")\n        return {"success": True, "config_path": config_path}\n\n    # Run workflow\n    console.print(f"\n[cyan]🚀 Running workflow for event: {event}[/cyan]")\n    if job:\n        console.print(f"   Specific job: {job}")\n    if use_container:\n        console.print("   Mode: Container-isolated execution")\n        if HAS_CONTAINER_RUNNER:\n            console.print("   Using: Enhanced container runner")\n\n    result = run_workflow(project_path, event, job, use_container=use_container)\n\n    if result["success"]:\n        console.print("\n[green]✅ Workflow completed successfully![/green]")\n        if result.get("stdout"):\n            console.print("\n[dim]Output:[/dim]")\n            console.print(Panel(result["stdout"][-1000:], title="Act Output (last 1000 chars)"))\n    else:\n        console.print("\n[red]❌ Workflow failed![/red]")\n        if result.get("error"):\n            console.print(f"Error: {result['error']}")\n        if result.get("stderr"):\n            console.print(Panel(result["stderr"][-1000:], title="Error Output (last 1000 chars)", style="red"))\n\n    return result\n\n\ndef main() -> None:\n    """CLI interface for act integration."""\n    import argparse\n\n    parser = argparse.ArgumentParser(description="DHT Act Integration - Run GitHub Actions locally")\n    parser.add_argument("path", nargs="?", default=".", help="Project path")\n    parser.add_argument("-e", "--event", default="push", help="GitHub event to simulate")\n    parser.add_argument("-j", "--job", help="Specific job to run")\n    parser.add_argument("--setup-only", action="store_true", help="Only setup, don't run")\n    parser.add_argument("-l", "--list", action="store_true", help="List workflows and exit")\n    parser.add_argument("--lint", action="store_true", help="Lint workflows with actionlint")\n    parser.add_argument("-c", "--container", action="store_true", help="Run act inside a container")\n\n    args = parser.parse_args()\n\n    project_path = Path(args.path).resolve()\n    integration = ActIntegration(project_path)\n\n    if args.list:\n        # List workflows\n        info = integration.list_workflows_and_jobs()\n\n        if not info["workflows"]:\n            print("No GitHub workflows found")\n            return\n\n        print(f"\nGitHub Workflows in {project_path.name}:")\n        print("=" * 60)\n\n        for workflow in info["workflows"]:\n            print(f"\n📄 {workflow['file']}")\n            if workflow.get("name"):\n                print(f"   Name: {workflow['name']}")\n            if workflow.get("on"):\n                print(f"   Triggers: {workflow['on']}")\n            if workflow.get("jobs"):\n                print(f"   Jobs: {', '.join(workflow['jobs'])}")\n            if workflow.get("error"):\n                print(f"   ⚠️  Error: {workflow['error']}")\n\n        print(f"\nTotal: {info['total_workflows']} workflows, {info['total_jobs']} jobs")\n        return\n\n    # Run the flow\n    result = act_workflow_flow(\n        project_path=str(project_path),\n        event=args.event,\n        job=args.job,\n        setup_only=args.setup_only,\n        lint_only=args.lint,\n        use_container=args.container,\n    )\n\n    # Exit with appropriate code\n    import sys\n\n    sys.exit(0 if result.get("success", False) else 1)\n\n\nif __name__ == "__main__":\n    main()
